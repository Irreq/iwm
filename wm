#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# File name: iwm
# Description: Irreqs Window Manager - A Simple Tiling WM With a Column Layout
# Author: irreq (irreq@protonmail.com)
# Date: 03/03/2022

"""Documentation:
--------------------------------------------------------------------------------
TODO:
    * Fix grow functions for windows


--------------------------------------------------------------------------------
Known Bugs:
0 - `VIRTUAL_SCREENS` must be more than one letter or switching is impossible.


"""

from Xlib import X, display, XK

import subprocess
import os
import sys
import signal
import datetime, traceback  # Debugging

# ----------- Config
VIRTUAL_SCREENS = "asdfgzxcv"

RULES = {  # Case sensitive groups
    "Alacritty": "g",
    "Firefox": "s",
    "Atom": "d",
}

# Keys
Mod = (1<<6)  # Super (mod4), aka "Windows" key
Control = (1<<2)
Shift = (1<<0)

keybinds = {  # (`Modifier` and `Key`) -> operation and/or arguments
    (Mod, "h"): ["warp", "left"],
    (Mod, "j"): ["warp", "down"],
    (Mod, "k"): ["warp", "up"],
    (Mod, "l"): ["warp", "right"],
    (Mod | Control, "h"): ["grow", "left"],
    (Mod | Control, "j"): ["grow", "down"],
    (Mod | Control, "k"): ["grow", "up"],
    (Mod | Control, "l"): ["grow", "right"],
    (Mod | Shift, "h"): ["shuffle", "left"],
    (Mod | Shift, "j"): ["shuffle", "down"],
    (Mod | Shift, "k"): ["shuffle", "up"],
    (Mod | Shift, "l"): ["shuffle", "right"],

    (Mod | Shift, "q"): "destroy_window",
    (Mod | Shift, "e"): "exit",
    (Mod | Shift, "r"): "restart",

    (Mod, "Return"): ["cmd", "/usr/bin/alacritty"],
    (Mod, "o"): ["cmd", "/usr/bin/dmenu_run"],

    (Mod, "comma"): ["cmd", "amixer -q sset Master 10%-"],
    (Mod, "period"): ["cmd", "amixer -q sset Master 10%+"],
    (Mod, "minus"): ["cmd", "/usr/bin/audio.py toggle"],
}

# Assign keybind to virtual screen.
for key in VIRTUAL_SCREENS:
    keybinds[(Mod, key)] = ["select_screen", key]
    keybinds[(Mod | Shift, key)] = ["move_to_screen", key]

# ----------- Functions
def debug(data, severity):
    """Debug system.

    severity chart:

    0 -> Success
    1 -> Notice
    2 -> Warning
    3 -> Error
    """

    caller = sys._getframe().f_back.f_code.co_name
    severity_table = {0: "\x1b[32m[SUCCESS]\x1b[0m",  # Green
                      1: "\x1b[34m[NOTICE]\x1b[0m",  # Blue
                      2: "\x1b[33m[WARNING]\x1b[0m",  # Yellow
                      3: "\x1b[31m[ERROR]\x1b[0m"}  # Red

    msg = (severity_table[severity], str(datetime.datetime.now()), data, caller)
    print('\n%s %s -> "%s" @ %s' % msg)
    return None

class Meta:
    row, col = None, None

    def __init__(self, window, group):
        self.window = window
        self.group = group
    def hide(self):
        self.window.unmap()
    def show(self):
        self.window.map()

class Screen:
    def __init__(self, group, **entries):
        self.group = group
        self.__dict__.update(entries)

    def hide(self):
        for win in self.get_windows():
            win.unmap()

    def show(self):
        for win in self.get_windows():
            win.map()

class Struct:
    def __init__(self, **entries):
        self.__dict__.update(entries)


class WM:
    """Main Window Manager Class"""
    EVENT_HANDLER =  {
        X.KeyPress: '_handle_keypress',
        X.MapRequest: '_handle_map_request',
        X.ConfigureRequest: '_handle_configure_request',
        X.MapNotify: '_handle_map_notify',
        X.UnmapNotify: '_handle_unmap_notify',
        X.EnterNotify: '_handle_enter_notify',
        X.DestroyNotify: '_handle_destroy_notify',
    }

    key_handlers = {}
    screens = {}
    running = True
    update = False

    # ----------- Initiation
    def __init__(self):
        signal.signal(signal.SIGINT, self.exit)  # Exit gracefully
        signal.signal(signal.SIGTERM, self.exit)

        self.display = display.Display()
        self.screen = self.display.screen()

        # Configure the root window to receive all events.
        mask = (X.SubstructureRedirectMask | X.SubstructureNotifyMask
                | X.EnterWindowMask | X.LeaveWindowMask | X.FocusChangeMask)

        self.screen.root.change_attributes(event_mask=mask)

        # Configure the root window to receive key inputs defined in `keybinds`.
        for modifier, key in keybinds:
            code = self.display.keysym_to_keycode(XK.string_to_keysym(key))
            self.screen.root.grab_key(code, modifier, 1, X.GrabModeAsync,
                                      X.GrabModeAsync)
            self.key_handlers[(modifier, code)] = (key, keybinds[(modifier, key)])

        self.current_screen = VIRTUAL_SCREENS[0]  # First screen
        # Prohibits switch loop
        self.previous_screen = VIRTUAL_SCREENS[-1]  # Requires more than one virtual screen

        # Find and manage all existing windows on startup.
        for window in self.screen.root.query_tree().children:
            name = window.get_wm_name()
            if name:
                pass

    # ----------- Event handlers
    def _handle_keypress(self, event):
        """Event handler for KeyPress events."""
        key, entry = self.key_handlers.get((event.state, event.detail),(None, None))
        if entry:
            if type(entry) != str:
                f, args = entry[0], entry[1:]
            else:
                f, args = entry, None
            method = getattr(self, f, None)
            if method:
                if args is not None:
                    method(event, *args)
                else:
                    method(event)

    def _handle_map_request(self, event):
        """Event handler for MapRequest events."""
        window = event.window
        window.map()
        self.manage_window(window)

    def _handle_configure_request(self, event):
        """Event handler for ConfigureRequest events."""
        window = event.window
        x, y = event.x, event.y
        width, height = event.width, event.height
        mask = event.value_mask
        if mask == 0b1111:
            window.configure(x=x, y=y, width=width, height=height)
        elif mask == 0b1100:
            window.configure(width=width, height=height)
        elif mask == 0b0011:
            window.configure(x=x, y=y)
        elif mask == 0b01000000:
            window.configure(event.stack_mode)

        self.update = True

    def _handle_map_notify(self, event):
        """Event handler for MapNotify events."""
        self.manage_window(event.window)

    def _handle_unmap_notify(self, event):
        """Event handler for UnmapNotify events."""
        self.get_screen().remove(event.window)
        self.update = True

    def _handle_enter_notify(self, event):
        """Event handler for EnterNotify events."""
        window = event.window
        if window in self.get_screen().get_windows():
            window.set_input_focus(X.RevertToParent, 0)

    def _handle_destroy_notify(self, event):
        """Event handler for DestroyNotify events."""
        window = event.window
        self.unmanage_window(window)

    # ----------- X wrapper functions
    def is_alive(self, window):
        """Check if `window` exist."""
        return window in self.screen.root.query_tree().children

    def is_managed(self, window):
        """Check if `window` is managed."""
        managed = False
        # for group, (data, windows) in self.screens.items():


    def manage_window(self, window):

        screen = self.get_screen()

        if window in self.windows: # Skip if the window is mapped
            debug("window is already mapped", 1)
            return

        try:
            attributes = window.get_attributes()
            if attributes.override_redirect:
                return
        except:
            debug("Could not get attributes, do not know severity.", 1)
            return

        window.map()
        mask = X.EnterWindowMask | X.LeaveWindowMask
        window.change_attributes(event_mask=mask)
        screen.add(window)
        self.update = True
        self.layout[self.current_screen] = screen

    def unmanage_window(self, window):
        screen = self.get_screen()
        if window in screen.get_windows():
            window, _ = screen.remove(window)
            window.unmap()
            self.update = True

    def add(self, window, group=None):
        if window in self.windows:  # Window cannot be added again
            return

        id = group or self.current_screen

        self.windows[window] = Meta



    # ----------- Callable Functions
    def warp(self, event, direction):
        if direction == "left":
            self.get_screen().column -= 1
        elif direction == "down":
            self.get_screen().row += 1
        elif direction == "up":
            self.get_screen().row -= 1
        elif direction == "right":
            self.get_screen().column += 1
        else:
            return debug("Unknown direction: %s" % str(direction), 2)

        self.get_screen().update()

    def grow(self, event, direction):
        screen = self.get_screen()
        win = event.child
        col, row = screen.get_position_from_window(win)
        if direction == "left":  # Require mouse to be on the right side
            if col == len(screen.layout) - 1:
                if col != 1:  # Fix this as it can only handle two col
                    return
                row, width = screen.layout[col]
                if width is None:  # Check if any other width is present
                    width = 1 / len(screen.layout)
                width += 0.1
                screen.layout[col] = [row, width]

        debug("Unfinished Function", 1)

    def shuffle(self, event, direction):
        debug("Unfinished Function", 1)

    def select_screen(self, event, n, toggle=True):
        """Change the virtual screen to `n`"""

        if toggle:
            if self.current_screen == n:
                n = self.previous_screen
            self.previous_screen = self.current_screen

        self.current_screen = n

        self.layout[self.previous_screen].hide()
        self.layout[self.current_screen].show()

    def _move_to_screen(self, win, group):
        screen = self.get_screen()
        window, height = screen.remove(win)
        if window is None:
            debug("Window could not be retrieved", 2)
            return
        new_screen = self.get_screen(id=group)
        new_screen.add(window)
        window.unmap()


    def move_to_screen(self, event, n, *args, move_with=False):
        if self.current_screen == n:  # You cannot move to your current screen
            return

        win = event.child

        screen = self.get_screen()
        window, height = screen.remove(win)
        if window is None:
            debug("Window could not be retrieved", 2)
            return

        new_screen = self.get_screen(id=n)
        new_screen.add(window)
        window.unmap()

        if move_with:
            screen.hide()
            self.current_screen = n
            new_screen.show()

        self.update = True

    def destroy_window(self, event, window=None):
        """Kill the window WINDOW."""

        if window is None:
            window = event.child

        window, height = self.get_screen().remove(window)
        window.destroy()
        self.update = True

    def cmd(self, event, *args):
        """Perform a command"""
        command = "".join(args)
        subprocess.Popen(command.split())

    def restart(self, event):
        os.execv(sys.argv[0], sys.argv)

    def exit(self, event, *args, **kwargs):
        self.running = False

    # ----------- Main Loop
    def loop(self):
        while self.running:
            try:
                event = self.display.next_event()
                if event.type in self.EVENT_HANDLER:
                    handler = getattr(self, self.EVENT_HANDLER[event.type], None)
                    if handler:
                        handler(event)
                        if self.update:
                            self.tile()
            except Exception as err:
                print("\n")
                traceback.print_tb(err.__traceback__)
                debug(str(err), 3)


debug("Starting the Window Manager...", 0)
wm = WM()
wm.loop()
